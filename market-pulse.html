import json
import os
from datetime import datetime, timezone
from pathlib import Path
import urllib.request

ROOT = Path(_file_).resolve().parents[1]
DATA_DIR = ROOT / "data"
MANUAL_PATH = DATA_DIR / "manual.json"
OUT_PATH = DATA_DIR / "market.json"

def utc_now_iso():
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat()

def load_manual():
    if MANUAL_PATH.exists():
        return json.loads(MANUAL_PATH.read_text(encoding="utf-8"))
    return {}

def fetch_json(url, timeout=20):
    req = urllib.request.Request(url, headers={"User-Agent": "ykcapitalholdings-market-pulse/1.0"})
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return json.loads(resp.read().decode("utf-8"))

def get_usdtry_frankfurter():
    # Frankfurter API (ECB-based). No key.
    # Docs: https://www.frankfurter.app/
    data = fetch_json("https://api.frankfurter.app/latest?from=USD&to=TRY")
    rate = data["rates"]["TRY"]
    as_of = data.get("date")  # YYYY-MM-DD
    return {
        "id": "usdtry",
        "label": "USD/TRY",
        "value": rate,
        "unit": "",
        "source": "Frankfurter (ECB)",
        "as_of": as_of,
        "status": "ok",
        "note": "ECB-based daily rate (not intraday)."
    }

def manual_series(manual, key, label, unit, source_note):
    entry = manual.get(key, {})
    val = entry.get("value", None)
    as_of = entry.get("as_of", None)
    note = entry.get("note", source_note)
    status = "manual" if val is not None else "missing"
    return {
        "id": key,
        "label": label,
        "value": val,
        "unit": unit,
        "source": entry.get("source", "Manual input"),
        "as_of": as_of,
        "status": status,
        "note": note
    }

def main():
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    manual = load_manual()

    series = []

    # Auto
    try:
        series.append(get_usdtry_frankfurter())
    except Exception as e:
        series.append({
            "id": "usdtry",
            "label": "USD/TRY",
            "value": None,
            "unit": "",
            "source": "Frankfurter (ECB)",
            "as_of": None,
            "status": "error",
            "note": f"Failed to fetch: {e}"
        })

    # Manual placeholders (until you have a licensed source / API)
    series.append(manual_series(
        manual, "wci", "Drewry World Container Index (WCI)", "USD/40ft",
        "Often proprietary; keep manual unless you have licensed access."
    ))
    series.append(manual_series(
        manual, "bdi", "Baltic Dry Index (BDI)", "Index",
        "Often behind licensed feeds; keep manual unless you have an API."
    ))
    series.append(manual_series(
        manual, "fbx", "Freightos Baltic Index (FBX)", "Index",
        "Often proprietary; keep manual unless you have an API."
    ))

    out = {
        "generated_at": utc_now_iso(),
        "series": series
    }

    OUT_PATH.write_text(json.dumps(out, indent=2, ensure_ascii=False), encoding="utf-8")
    print(f"Wrote {OUT_PATH} with {len(series)} series.")

if _name_ == "_main_":
    main()
